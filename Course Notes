TypeScript - super set of JS
  - You define if something is a String, Number, Integer, etc.
  - Also has more features than Vanilla js - has Types, Classes, Interfaces, etc.
    - which means its checks in the moment, not just when it runs in browser.
  - typescript must be compiled to JS inorder to run in the browser.
index.html is what takes us to the main page - only page loaded by the backend, everything else is angular frontend routing
  - its what is loadeded first
  - and where all the files are all imported to.
  - app-root is where it all goes.
main.ts - is the first TypesScript code that gets run.
  - this is where our bootstrapModule is ( not to be confused with Bootstrap CSS)
    - We start our Angular application by passing an AppModule through this platformBrowserDynamic().bootstrapModule() method
      (we also much import AppModule at top of page and it refers to our app.module.ts file)
app.module.ts - where we have our NgModule.
  - bootstrap is an object within the NgModule array.
    - bootstrap within its own array called AppComponent.
    - which references our AppComponent - so now Angular knows to look at the app components to start running these files.
app.component.ts - here is the selector: app-root which is called in the index.html file.
  - Angular knows that the <app-root> in the index.html file is calling on the app.component.ts which also has an app.component.html file which is what is inserted into the app-root in the index.html file.

WHAT ARE COMPONENTS
  - You build your whole app by composing it from a couple of components - you make yourself.
  - Angular gives you app.component which is the root component
    - where we will add/nest our other components to so they render on the web page.
  - Common components - headers (even items within a header can be their own components), sidebar component, main page component.
  - Each component has its own html file, its own css file, its own test file and its own TS file.
    - these are reuseable, so they can be used multiple times throughout your application.
    - very easy to update and to exchange parts within it.
How to create a COMPONENT:
  -AppComponent - is normal and a special component at the same time.
  - a component is simply a TS class - so that angular is able to create objects based on the blueprint.
  - the server.component.ts file is made up of: imports, the 'class' that is exported, and the @Component object:
    - To distinguish that this is not a normal type script class we must establish it is a COMPONENT.
      - Decorator - a typescript feature that allows you to enhance your class
        - it always has an @ sign infront to show that it is a decorator.
        - @Component - TS doesn't know if from the start so you have to import it 'import {Component} from '@angular/core'
        - app/core has some of the main features of Angular. its one of the packages that comes with the CLI.
        -Now we pass a JS object through it - its stored as meta data which will tell angular what to do with this Component
        1. selector - it is a string - it is the html tag that is placed in the app.component.html file so it'll render to the webpage
          (it can go in other components and multiple components when the website is more complex)
          - its autogenerated in the command line
          - it has to be unique*
          - it usually starts with "app- " and after the dash is the unique name of the component.
          - ours is app-server.
        2. templateUrl: is the relative path to the html file - './server.component.html'
        3. stylesUrl - it is optiontial = and it is just like the templateUrl but for the CSS file of this component
    - IN THE app.module.ts FILE MUST UPDATE with SERVER.component INFORMATION
      - What is the AppModule? - Angular uses components to build webpages and Modules to basically bundle different piees of your app (like components) into packages.
        - In bigger apps you can have multiple modules, but for our app you really only need one module.
        - It gives ANgular the information "which features does my app have and use?"
        - it has a type script class like our components
        - BUT we change it into something more than a class and different from a component with our DECORATOR
          - we use the @NgModule decorator  which is also imported from angular/core.
          - it has 4 properties: declarations, imports, providers and bootstrap.
            1. bootstrap - this was responsible for telling Angular which component it should be aware at the time the WHOLE application STARTS.
              (which component should you recognize in the index.html file - thats the AppComponent)
              - ** bc we do not add anything to the index.html file, we won't change anything about the bootstrap array in the decorator object" **
            2. declarations - where we register new components - the terminal does this for you if you do 'ng g c "name of new component"'
              - we register ServerComponent here so Angulat knows it exists
              - bc by default ANGULAR WILL NOT SCAN ALL OF YOUR FILES, SO YOU MUST DECLARE THEM.
              - ServerComponent also needs to be imported at the top of the file. - so typescript can find the file.
            3. imports array - where we but the module's we import and want to use throughout our app. THey are built into Angular
              - BrowserModule - gives us the base functionality we need to start our application.
              - OTHERS LATER
            4. providers - COME BACK TO LATER

  ServersComponent - lets write some code.
    - Inside servers.component.ts we can change out templateUrl to template. - you can have either and you MUST HAVE EITHER OR.
    - using backtics `` you can now write multiline strings for the html in your template string in the component.ts file.
      - IF YOU DON't HAVE MUCH HTML CODE - using an inline template with backtics inside the TS file might be fine.
      - If you have alot of code - stick with templateUrl and an additional file for the html.
      @Component({
        selector: 'app-servers',
        template: `
        <app-server></app-server>
        <app-server></app-server>`,
        styleUrls: ['./servers.component.css']
      })
    Instead of having a CSS file we can also change the styleUrls to style and put it in the TS file.
      - Again we need backtics but here we need to place it inside of an Array - styles: [``]
        - b/c its an array you can have multiple styles in it.
        @Component({
        selector: 'app-root',
        templateUrl: 'app.component.html'
        styles: [`
          h3 {
            color: dodgerblue;
          }
        `]
      })
    YOU HAVE TO DECIDE WHICH ONE TO DO, CAN'T DO BOTH templateUrl and template or styleUrls and styles
  Now the Selector - which is "selector: 'app-root'" for app.component
    -This is basically creating an element to put into an html file.
      - currently this string is then placed in an Element tag in the html <app-server><app-server> tag.
  But you don't have to use this type of selector, you arent limited to elements
  You can put your selector in [] square brackets to use the attributes selector
  @Component({
    selector: ['app-servers'],
    templateUrl: 'servers.component.html'
    styleUrls: ['./servers.component.css']
  })
  BUT you also have to change how it is inserted into the HTML file b/c it is NO LONGER AN ELEMENT IT IS AN ATTRIBUTE.
    <div app-servers></div> instead of <app-servers></app-servers>
  ANOTHER WAY is to SELECT by CLASS:
  selector: '.app-servers', - add the period infront in the TS file to distinguish it is a html class
  <div class="app-servers"></div>
    ** Selecting by id WON'T WORK - its not supported by Angular **
  ***Normally you just use the element tags though - these are just alternatives.***
  Directives is another way to do call on a component INSTEAD of the selector
    -WILL LEARN LATER

Databinding = communication
communication between your typescript code (business logic) and your template html code.
output data - output data from TS code into our html code
- using string interpolation {{data}} or
- property binding [property] = "data"
React to user events - to go from html to TS code
- Event binding (event)="expression"
two-way binding - a combo of out and react events happneing at the same time.
-two-way-binding [(ngModel)]="data"

String Interpolation
-the {{}} are required and they can be a variable passed through it, you can write a string in there, you can even call a method (function) and pass it.
-But it can't be multiline - so for EX you can't do an if statement.
Our Example in serverComponent
-In the TS under the class:
  serverId: number = 10;
  serverStatus: string = 'offline';
-In the html these variables are called:
  <p>{{'Server'}} ID {{serverId}} is {{serverStatus}}</p>
  - 'Server' is just a string we decided to add here.
  - We didn't include a method yet
-String interpolation has to return a string in the end
-Now lets use a method
  <p>{{'Server'}} ID {{serverId}} is {{serverStatus}}</p>{{getServerStatus()}}
  ----------------------------------------------------------------
  getServerStatus() {
    return this.serverStatus;
  }
  -its the same output - bc it just returns the string that is the serverStatus variable.

Property Binding:
-Now adding to the HTML element a button and we want it to be disabled at first and then enabled after a set timeout so first here is the html:
  <button class="btn btn-primary" disabled>Add Server</button>
  - the button is currently hardcoded now and we will fix this after we make out TS code.
-Here is the TS:
  allowNewServer = false;

  constructor() {
    setTimeout(() => {
      this.allowNewServer = true;
    }, 2000)
  }
  - our variable is set to false - so maybe this is saying button is NOT enabled.
  - inside our constructor - which runs when the file is initiated - we have a setTimeout function. It says after 2000 miliseconds (2 seconds) set this.allowNewServer (ServersComponent.allowNewServer) to TRUE.

-since disabled is hardcoded nothing is changing. so here is where we use PROPERTY BINDING
put square brackets around [disabled] in the html element
  <button class="btn btn-primary" [disabled]="allowNewServer">Add Server</button>
  - these [] indicate to angular that we are using property binding and that we want to  dynamically bind some property and disabled (the html attribute).
  - normally each html line is parsed by the browser and kind of translated into an element on the DOM (document Object model)
    **There are many HTML properties that we can do property binding with**
    - so here we have an element with a couple of properties but we focus on using the diabled to call on allowNewServer.
    -the [disabled] is now set equal to allowNewServer - which we know will change b/c of the setTimeout method.
    - WHICH MEANS THE BUTTON IS ONLY DISABLED IF allowNewServer IS TRUE
    -so we change it to:
    <button class="btn btn-primary" [disabled]="allowNewServer">Add Server</button>
      - now the button is ONLY DISABLED IF allowNewServer is FALSE.
    so now it is disabled at first when the boolean is false, but when the boolean changes to True, it is enabled!
** Now updates happen DYNAMICALLY
** You dont have to just bind to html properties, you can also bind too:
  - Directives
  - Your own components

String Interpolation VS Property Binding
  <p>{{allowNewServer}}</p> string interpolation
  <p [innerText]="allowNewServer"></p> property binding with the innerText - an element property of <p>
- these both give us the same thing - they are interchangable in this case.
** Don't mix property binding and string interpolation - you cannot put curly brackets inside of the quotes of property binding. Those brackets are used to designate typescript code, but the quotes are enough to designate the TS code for property binding. **
- just like string interpolation, you can call a method in the quots of property binding, you just CANNOT use curly brackets inside of the quotes.

Event Binging
- We want to create an output. So for our example inside of the servers.component.ts we are adding a new variable:
  serverCreationStatus: String = "No server was created!"
-Now in the servers.component.html we add this with string interpolation:
  <p>{{serverCreationStatus}}</p>
-Back to the TS we add a new method
** we name is starting with 'on' so we know it is initated in the html template. Like a js onClick - even though its click in Angular NOT onClick. **
  onCreateServer() {
    this.serverCreationStatus = 'Server was created!'
  }
-NOW we need to create the click event, the EVENT BINDING:
- Event binding uses () just like property binding uses [] in the html element:
<button class="btn btn-primary"
[disabled]="!allowNewServer"
(click)="onCreateServer()">Add Server</button>
- between the "" we put the code we want to be executed in the html when the EVENT happens.AND it is normally a method, like we called here.
  - You could put the code you want exeuted directly in the "" instead of calling on a method in the TS file. BUt usually its a good rule of thumb to have as little TS code in the html as possible.

Passing and using data with event binding
-For our example we are making a label that our button will work with:
  <label>Server Name</label>
  <input
  type="text"
  class="form-control"
  (input)="onUpdateServerName($event)">
- We have another event binding with input and we are calling on a method we create in the TS called "onUpdateServerName"
  - We are passing $event through it because its a reserved variable name that you can use in the template when you are using event binding.
  - Here between the "", $event is equal to the data emitted from this click event.
  - So input and event are default events provided by the DOM and they both give us data when they are fired.
  **$event is a reserved word that gives us access to the click event data**
Now lets create the method in the ts file
  onUpdateServerName(event: any) {
    console.log(event)
  }
- First we will just log it to the console to see what information we get about the event data.
  -event is any event
- When you try this, a new event object output is displayed in the console for every character you enter.

Two-Way BINDING
-Lets replace the input event with something else - ngModel.
*@angular/forms needs to be added to your imports array [] in the AddModule - and this should be a default in a CLI project.
[(ngModel)]="serverName"
- This will trigger on the input event and update the value of serverName in our component automatically.
- Since it is two-way binding, it'll also update the value of the input element if we change server name somewhere else.
  - If we go into servers.component.ts and change serverName = 'TestServer' instead of an empty string ''.
    -Now the input is prepopulated with 'TestServer' is "serverName".
    -As you type something in the input it updates the property name, it updates where we use string interpolation
    - if you uncommented the original event bidding that was one direction:
    <input
    type="text"
    class="form-control"
    (input)="onUpdateServerName($event)">
    - You can type into that input area and the new input AND the p with string interpolation are updated.
    - when you type into the NEW input area (ngModel) only the new input area and the p with SI are updated, NOT the old input area. this is because the old input is NOT two way binding.
- ** Reacting to events in both directions** -

Combining all forms of databinding:
- now instead of just displaying the server name - line 10 - <p>{{serverName}}</p> - we want it to display when we click the button.
- In the TS file we can update onCreateServer() method to include the new serveName:
  onCreateServer() {
    this.serverCreationStatus = 'Server was created! Name is ' + this.serverName;
  }
  - No when you click the Add Server button in the site it'll update based on the input:
  if you input "TestServer 2" it'll display "Server was created! Name is TestServer 2" below the button - where serverCreationStatus is called in:
  string interpolation (line 15 - <p>{{serverCreationStatus}}</p> )
  and in property binding (line 16 - <p [innerText]="serverCreationStatus"></p>)

Understanding Directives:










NgModule - need to make sure to import features such as FormsModule in app.module.ts
Components and DataBindings
Directives
Services and Dependency Injections
Routing
Observables - helps us with asynchronous code
forms
pipes
http
authentication
optimization
NgModules
Deployment
Animations & Testing.
